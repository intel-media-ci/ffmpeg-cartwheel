From 355cf5202eda12cdc67aa7ba807e4568c6d4e843 Mon Sep 17 00:00:00 2001
From: Wenbinc-Bin <wenbin.chen@intel.com>
Date: Tue, 19 Jan 2021 14:37:05 +0800
Subject: [PATCH 4/7] libavocdec/qsvenc_hevc: encode RGB format rawvideo

Add support for hevc_qsv to input RGB format frame. It will
transform frame to yuv inside MediaSDK instead of using auto
scale. Hevc_qsv supports directly encoding BGRA and X2RGB10Le format.
X2RGB10Le is only supported in VDENC (-low_power 1).
The X2RGB10Le correspond to the A2RGB20 format in MediaSDK, and for
A2RGB10 the two MSBs is A channels while this two bits in X2RGB10Le is
undefined. MediaSDK team is discussing about this, so I leave an interface
here.

Sigend-of-by Wenbin Chen <wenbin.chen@intel.com>
---
 libavcodec/qsv.c         |  6 ++++++
 libavcodec/qsvenc.c      | 12 ++++++++++--
 libavcodec/qsvenc_hevc.c |  2 ++
 3 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/libavcodec/qsv.c b/libavcodec/qsv.c
index 1df0f7c7d2..2fb13dd860 100644
--- a/libavcodec/qsv.c
+++ b/libavcodec/qsv.c
@@ -279,6 +279,12 @@ int ff_qsv_map_pixfmt(enum AVPixelFormat format, uint32_t *fourcc)
         return AV_PIX_FMT_Y412;
 #endif
 #endif
+    case AV_PIX_FMT_BGRA:
+        *fourcc = MFX_FOURCC_RGB4;
+        return AV_PIX_FMT_BGRA;
+    case AV_PIX_FMT_X2RGB10LE:
+        *fourcc = MFX_FOURCC_A2RGB10;
+        return AV_PIX_FMT_X2RGB10LE;
     default:
         return AVERROR(ENOSYS);
     }
diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
index 8708e9b224..3c62c2ba64 100644
--- a/libavcodec/qsvenc.c
+++ b/libavcodec/qsvenc.c
@@ -1447,8 +1447,16 @@ static int submit_frame(QSVEncContext *q, const AVFrame *frame,
             qf->surface.Info.PicStruct |= MFX_PICSTRUCT_FRAME_TRIPLING;
 
         qf->surface.Data.PitchLow  = qf->frame->linesize[0];
-        qf->surface.Data.Y         = qf->frame->data[0];
-        qf->surface.Data.UV        = qf->frame->data[1];
+        if (frame->format == AV_PIX_FMT_X2RGB10LE ||
+            frame->format == AV_PIX_FMT_BGRA) {
+            qf->surface.Data.B         = qf->frame->data[0];
+            qf->surface.Data.G         = qf->frame->data[0] + 1;
+            qf->surface.Data.R         = qf->frame->data[0] + 2;
+            qf->surface.Data.A         = qf->frame->data[0] + 3;
+        } else {
+            qf->surface.Data.Y         = qf->frame->data[0];
+            qf->surface.Data.UV        = qf->frame->data[1];
+        }
     }
 
     qf->surface.Data.TimeStamp = av_rescale_q(frame->pts, q->avctx->time_base, (AVRational){1, 90000});
diff --git a/libavcodec/qsvenc_hevc.c b/libavcodec/qsvenc_hevc.c
index af1c715e9d..b30f7a4481 100644
--- a/libavcodec/qsvenc_hevc.c
+++ b/libavcodec/qsvenc_hevc.c
@@ -289,6 +289,8 @@ AVCodec ff_hevc_qsv_encoder = {
     .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_NV12,
                                                     AV_PIX_FMT_P010,
                                                     AV_PIX_FMT_QSV,
+                                                    AV_PIX_FMT_BGRA,
+                                                    AV_PIX_FMT_X2RGB10LE,
                                                     AV_PIX_FMT_NONE },
     .priv_class     = &class,
     .defaults       = qsv_enc_defaults,
-- 
2.25.1

